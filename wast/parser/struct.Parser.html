<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An in-progress parser for the tokens of a WebAssembly text file."><title>Parser in wast::parser - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="wast" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../wast/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../wast/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Parser</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.cur_span">cur_span</a></li><li><a href="#method.error">error</a></li><li><a href="#method.error_at">error_at</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.lookahead1">lookahead1</a></li><li><a href="#method.parens">parens</a></li><li><a href="#method.parens_depth">parens_depth</a></li><li><a href="#method.parse">parse</a></li><li><a href="#method.peek">peek</a></li><li><a href="#method.peek2">peek2</a></li><li><a href="#method.peek3">peek3</a></li><li><a href="#method.prev_span">prev_span</a></li><li><a href="#method.register_annotation">register_annotation</a></li><li><a href="#method.step">step</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Clone-for-Parser%3C'a%3E">Clone</a></li><li><a href="#impl-Copy-for-Parser%3C'a%3E">Copy</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-Parser%3C'a%3E">!RefUnwindSafe</a></li><li><a href="#impl-Send-for-Parser%3C'a%3E">!Send</a></li><li><a href="#impl-Sync-for-Parser%3C'a%3E">!Sync</a></li><li><a href="#impl-UnwindSafe-for-Parser%3C'a%3E">!UnwindSafe</a></li><li><a href="#impl-Unpin-for-Parser%3C'a%3E">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-Parser%3C'a%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Parser%3C'a%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Parser%3C'a%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Parser%3C'a%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Parser%3C'a%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-Parser%3C'a%3E">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Parser%3C'a%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Parser%3C'a%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In wast::parser</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">wast</a>::<wbr><a href="index.html">parser</a>::<wbr><a class="struct" href="#">Parser</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/wast/parser.rs.html#339-341">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Parser&lt;'a&gt; { /* private fields */ }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An in-progress parser for the tokens of a WebAssembly text file.</p>
<p>A <code>Parser</code> is argument to the <a href="trait.Parse.html" title="trait wast::parser::Parse"><code>Parse</code></a> trait and is now the input stream is
interacted with to parse new items. Cloning <a href="struct.Parser.html" title="struct wast::parser::Parser"><code>Parser</code></a> or copying a parser
refers to the same stream of tokens to parse, you cannot clone a <a href="struct.Parser.html" title="struct wast::parser::Parser"><code>Parser</code></a>
and clone two items.</p>
<p>For more information about a <a href="struct.Parser.html" title="struct wast::parser::Parser"><code>Parser</code></a> see its methods.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Parser%3C'a%3E" class="impl"><a class="srclink rightside" href="../../src/wast/parser.rs.html#476-980">source</a><a href="#impl-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#486-492">source</a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether there are no more <code>Token</code> tokens to parse from this
<a href="struct.Parser.html" title="struct wast::parser::Parser"><code>Parser</code></a>.</p>
<p>This indicates that either we’ve reached the end of the input, or we’re
a sub-<a href="struct.Parser.html" title="struct wast::parser::Parser"><code>Parser</code></a> inside of a parenthesized expression and we’ve hit the
<code>)</code> token.</p>
<p>Note that if <code>false</code> is returned there <em>may</em> be more comments. Comments
and whitespace are not considered for whether this parser is empty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#552-554">source</a><h4 class="code-header">pub fn <a href="#method.parse" class="fn">parse</a>&lt;T: <a class="trait" href="trait.Parse.html" title="trait wast::parser::Parse">Parse</a>&lt;'a&gt;&gt;(self) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Parses a <code>T</code> from this <a href="struct.Parser.html" title="struct wast::parser::Parser"><code>Parser</code></a>.</p>
<p>This method has a trivial definition (it simply calls
<a href="trait.Parse.html#tymethod.parse" title="associated function wast::parser::Parse::parse"><code>T::parse</code></a>) but is here for syntactic purposes. This is
what you’ll call 99% of the time in a <a href="trait.Parse.html" title="trait wast::parser::Parse"><code>Parse</code></a> implementation in order
to parse sub-items.</p>
<p>Typically you always want to use <code>?</code> with the result of this method, you
should not handle errors and decide what else to parse. To handle
branches in parsing, use <a href="struct.Parser.html#method.peek" title="method wast::parser::Parser::peek"><code>Parser::peek</code></a>.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<p>A good example of using <code>parse</code> is to see how the <a href="../core/struct.TableType.html" title="struct wast::core::TableType"><code>TableType</code></a> type is
parsed in this crate. A <a href="../core/struct.TableType.html" title="struct wast::core::TableType"><code>TableType</code></a> is defined in the official
specification as <a href="https://webassembly.github.io/spec/core/text/types.html#table-types"><code>tabletype</code></a> and is defined as:</p>
<div class="example-wrap"><pre class="language-text"><code>tabletype ::= lim:limits et:reftype
</code></pre></div>
<p>so to parse a <a href="../core/struct.TableType.html" title="struct wast::core::TableType"><code>TableType</code></a> we recursively need to parse a <a href="../core/struct.Limits.html" title="struct wast::core::Limits"><code>Limits</code></a>
and a <a href="../core/struct.RefType.html" title="struct wast::core::RefType"><code>RefType</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>TableType&lt;<span class="lifetime">&#39;a</span>&gt; {
    limits: Limits,
    elem: RefType&lt;<span class="lifetime">&#39;a</span>&gt;,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Parse&lt;<span class="lifetime">&#39;a</span>&gt; <span class="kw">for </span>TableType&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>parse(parser: Parser&lt;<span class="lifetime">&#39;a</span>&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        <span class="comment">// parse the `lim` then `et` in sequence
        </span><span class="prelude-val">Ok</span>(TableType {
            limits: parser.parse()<span class="question-mark">?</span>,
            elem: parser.parse()<span class="question-mark">?</span>,
        })
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#609-611">source</a><h4 class="code-header">pub fn <a href="#method.peek" class="fn">peek</a>&lt;T: <a class="trait" href="trait.Peek.html" title="trait wast::parser::Peek">Peek</a>&gt;(self) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.1/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Performs a cheap test to see whether the current token in this stream is
<code>T</code>.</p>
<p>This method can be used to efficiently determine what next to parse. The
<a href="trait.Peek.html" title="trait wast::parser::Peek"><code>Peek</code></a> trait is defined for types which can be used to test if they’re
the next item in the input stream.</p>
<p>Nothing is actually parsed in this method, nor does this mutate the
state of this <a href="struct.Parser.html" title="struct wast::parser::Parser"><code>Parser</code></a>. Instead, this simply performs a check.</p>
<p>This method is frequently combined with the <a href="struct.Parser.html#method.lookahead1" title="method wast::parser::Parser::lookahead1"><code>Parser::lookahead1</code></a>
method to automatically produce nice error messages if some tokens
aren’t found.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>For an example of using the <code>peek</code> method let’s take a look at parsing
the <a href="../core/struct.Limits.html" title="struct wast::core::Limits"><code>Limits</code></a> type. This is <a href="https://webassembly.github.io/spec/core/text/types.html#limits">defined in the official spec</a> as:</p>
<div class="example-wrap"><pre class="language-text"><code>limits ::= n:u32
         | n:u32 m:u32
</code></pre></div>
<p>which means that it’s either one <code>u32</code> token or two, so we need to know
whether to consume two tokens or one:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Limits {
    min: u32,
    max: <span class="prelude-ty">Option</span>&lt;u32&gt;,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Parse&lt;<span class="lifetime">&#39;a</span>&gt; <span class="kw">for </span>Limits {
    <span class="kw">fn </span>parse(parser: Parser&lt;<span class="lifetime">&#39;a</span>&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        <span class="comment">// Always parse the first number...
        </span><span class="kw">let </span>min = parser.parse()<span class="question-mark">?</span>;

        <span class="comment">// ... and then test if there&#39;s a second number before parsing
        </span><span class="kw">let </span>max = <span class="kw">if </span>parser.peek::&lt;u32&gt;()<span class="question-mark">? </span>{
            <span class="prelude-val">Some</span>(parser.parse()<span class="question-mark">?</span>)
        } <span class="kw">else </span>{
            <span class="prelude-val">None
        </span>};

        <span class="prelude-val">Ok</span>(Limits { min, max })
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek2" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#615-617">source</a><h4 class="code-header">pub fn <a href="#method.peek2" class="fn">peek2</a>&lt;T: <a class="trait" href="trait.Peek.html" title="trait wast::parser::Peek">Peek</a>&gt;(self) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.1/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Same as the <a href="struct.Parser.html#method.peek" title="method wast::parser::Parser::peek"><code>Parser::peek</code></a> method, except checks the next token, not
the current token.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek3" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#621-632">source</a><h4 class="code-header">pub fn <a href="#method.peek3" class="fn">peek3</a>&lt;T: <a class="trait" href="trait.Peek.html" title="trait wast::parser::Peek">Peek</a>&gt;(self) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.72.1/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Same as the <a href="struct.Parser.html#method.peek2" title="method wast::parser::Parser::peek2"><code>Parser::peek2</code></a> method, except checks the next next token,
not the next token.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lookahead1" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#683-688">source</a><h4 class="code-header">pub fn <a href="#method.lookahead1" class="fn">lookahead1</a>(self) -&gt; <a class="struct" href="struct.Lookahead1.html" title="struct wast::parser::Lookahead1">Lookahead1</a>&lt;'a&gt;</h4></section></summary><div class="docblock"><p>A helper structure to perform a sequence of <code>peek</code> operations and if
they all fail produce a nice error message.</p>
<p>This method purely exists for conveniently producing error messages and
provides no functionality that <a href="struct.Parser.html#method.peek" title="method wast::parser::Parser::peek"><code>Parser::peek</code></a> doesn’t already give.
The <a href="struct.Lookahead1.html" title="struct wast::parser::Lookahead1"><code>Lookahead1</code></a> structure has one main method <a href="struct.Lookahead1.html#method.peek" title="method wast::parser::Lookahead1::peek"><code>Lookahead1::peek</code></a>,
which is the same method as <a href="struct.Parser.html#method.peek" title="method wast::parser::Parser::peek"><code>Parser::peek</code></a>. The difference is that the
<a href="struct.Lookahead1.html#method.error" title="method wast::parser::Lookahead1::error"><code>Lookahead1::error</code></a> method needs no arguments.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<p>Let’s look at the parsing of <a href="../token/enum.Index.html" title="enum wast::token::Index"><code>Index</code></a>. This type is either a <code>u32</code> or
an <a href="../token/struct.Id.html" title="struct wast::token::Id"><code>Id</code></a> and is used in name resolution primarily. The <a href="https://webassembly.github.io/spec/core/text/modules.html#indices">official
grammar for an index</a> is:</p>
<div class="example-wrap"><pre class="language-text"><code>idx ::= x:u32
      | v:id
</code></pre></div>
<p>Which is to say that an index is either a <code>u32</code> or an <a href="../token/struct.Id.html" title="struct wast::token::Id"><code>Id</code></a>. When
parsing an <a href="../token/enum.Index.html" title="enum wast::token::Index"><code>Index</code></a> we can do:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span>Index&lt;<span class="lifetime">&#39;a</span>&gt; {
    Num(u32),
    Id(Id&lt;<span class="lifetime">&#39;a</span>&gt;),
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Parse&lt;<span class="lifetime">&#39;a</span>&gt; <span class="kw">for </span>Index&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>parse(parser: Parser&lt;<span class="lifetime">&#39;a</span>&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>l = parser.lookahead1();
        <span class="kw">if </span>l.peek::&lt;Id&gt;()<span class="question-mark">? </span>{
            <span class="prelude-val">Ok</span>(Index::Id(parser.parse()<span class="question-mark">?</span>))
        } <span class="kw">else if </span>l.peek::&lt;u32&gt;()<span class="question-mark">? </span>{
            <span class="prelude-val">Ok</span>(Index::Num(parser.parse()<span class="question-mark">?</span>))
        } <span class="kw">else </span>{
            <span class="comment">// produces error message of `expected identifier or u32`
            </span><span class="prelude-val">Err</span>(l.error())
        }
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parens" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#734-759">source</a><h4 class="code-header">pub fn <a href="#method.parens" class="fn">parens</a>&lt;T&gt;(self, f: impl <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt;) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Parse an item surrounded by parentheses.</p>
<p>WebAssembly’s text format is all based on s-expressions, so naturally
you’re going to want to parse a lot of parenthesized things! As noted in
the documentation of <a href="trait.Parse.html" title="trait wast::parser::Parse"><code>Parse</code></a> you typically don’t parse your own
surrounding <code>(</code> and <code>)</code> tokens, but the parser above you parsed them for
you. This is method method the parser above you uses.</p>
<p>This method will parse a <code>(</code> token, and then call <code>f</code> on a sub-parser
which when finished asserts that a <code>)</code> token is the next token. This
requires that <code>f</code> consumes all tokens leading up to the paired <code>)</code>.</p>
<p>Usage will often simply be <code>parser.parens(|p| p.parse())?</code> to
automatically parse a type within parentheses, but you can, as always,
go crazy and do whatever you’d like too.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<p>A good example of this is to see how a <code>Module</code> is parsed. This isn’t
the exact definition, but it’s close enough!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Module&lt;<span class="lifetime">&#39;a</span>&gt; {
    fields: Vec&lt;ModuleField&lt;<span class="lifetime">&#39;a</span>&gt;&gt;,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Parse&lt;<span class="lifetime">&#39;a</span>&gt; <span class="kw">for </span>Module&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>parse(parser: Parser&lt;<span class="lifetime">&#39;a</span>&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        <span class="comment">// Modules start out with a `module` keyword
        </span>parser.parse::&lt;kw::module&gt;()<span class="question-mark">?</span>;

        <span class="comment">// And then everything else is `(field ...)`, so while we&#39;ve got
        // items left we continuously parse parenthesized items.
        </span><span class="kw">let </span><span class="kw-2">mut </span>fields = Vec::new();
        <span class="kw">while </span>!parser.is_empty() {
            fields.push(parser.parens(|p| p.parse())<span class="question-mark">?</span>);
        }
        <span class="prelude-val">Ok</span>(Module { fields })
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parens_depth" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#765-767">source</a><h4 class="code-header">pub fn <a href="#method.parens_depth" class="fn">parens_depth</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the depth of nested parens we’ve parsed so far.</p>
<p>This is a low-level method that is only useful for implementing
recursion limits in custom parsers.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.step" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#791-798">source</a><h4 class="code-header">pub fn <a href="#method.step" class="fn">step</a>&lt;F, T&gt;(self, f: F) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt;<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="struct" href="struct.Cursor.html" title="struct wast::parser::Cursor">Cursor</a>&lt;'a&gt;) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;(T, <a class="struct" href="struct.Cursor.html" title="struct wast::parser::Cursor">Cursor</a>&lt;'a&gt;)&gt;,</span></h4></section></summary><div class="docblock"><p>A low-level parsing method you probably won’t use.</p>
<p>This is used to implement parsing of the most primitive types in the
<a href="../core/index.html" title="mod wast::core"><code>core</code></a> module. You probably don’t want to use this, but
probably want to use something like <a href="struct.Parser.html#method.parse" title="method wast::parser::Parser::parse"><code>Parser::parse</code></a> or
<a href="struct.Parser.html#method.parens" title="method wast::parser::Parser::parens"><code>Parser::parens</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.error" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#806-808">source</a><h4 class="code-header">pub fn <a href="#method.error" class="fn">error</a>(self, msg: impl <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>) -&gt; <a class="struct" href="../struct.Error.html" title="struct wast::Error">Error</a></h4></section></summary><div class="docblock"><p>Creates an error whose line/column information is pointing at the
current token.</p>
<p>This is used to produce human-readable error messages which point to the
right location in the input stream, and the <code>msg</code> here is arbitrary text
used to associate with the error and indicate why it was generated.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.error_at" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#812-814">source</a><h4 class="code-header">pub fn <a href="#method.error_at" class="fn">error_at</a>(self, span: <a class="struct" href="../token/struct.Span.html" title="struct wast::token::Span">Span</a>, msg: impl <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>) -&gt; <a class="struct" href="../struct.Error.html" title="struct wast::Error">Error</a></h4></section></summary><div class="docblock"><p>Creates an error whose line/column information is pointing at the
given span.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cur_span" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#817-819">source</a><h4 class="code-header">pub fn <a href="#method.cur_span" class="fn">cur_span</a>(&amp;self) -&gt; <a class="struct" href="../token/struct.Span.html" title="struct wast::token::Span">Span</a></h4></section></summary><div class="docblock"><p>Returns the span of the current token</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prev_span" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#822-826">source</a><h4 class="code-header">pub fn <a href="#method.prev_span" class="fn">prev_span</a>(&amp;self) -&gt; <a class="struct" href="../token/struct.Span.html" title="struct wast::token::Span">Span</a></h4></section></summary><div class="docblock"><p>Returns the span of the previous token</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.register_annotation" class="method"><a class="srclink rightside" href="../../src/wast/parser.rs.html#958-979">source</a><h4 class="code-header">pub fn <a href="#method.register_annotation" class="fn">register_annotation</a>&lt;'b&gt;(self, annotation: &amp;'b <a class="primitive" href="https://doc.rust-lang.org/1.72.1/std/primitive.str.html">str</a>) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> + 'b<span class="where fmt-newline">where
    'a: 'b,</span></h4></section></summary><div class="docblock"><p>Registers a new known annotation with this parser to allow parsing
annotations with this name.</p>
<p><a href="https://github.com/WebAssembly/annotations">WebAssembly annotations</a> are a proposal for the text format
which allows decorating the text format with custom structured
information. By default all annotations are ignored when parsing, but
the whole purpose of them is to sometimes parse them!</p>
<p>To support parsing text annotations this method is used to allow
annotations and their tokens to <em>not</em> be skipped. Once an annotation is
registered with this method, then while the return value has not been
dropped (e.g. the scope of where this function is called) annotations
with the name <code>annotation</code> will be parse of the token stream and not
implicitly skipped.</p>
<h5 id="skipping-annotations"><a href="#skipping-annotations">Skipping annotations</a></h5>
<p>The behavior of skipping unknown/unregistered annotations can be
somewhat subtle and surprising, so if you’re interested in parsing
annotations it’s important to point out the importance of this method
and where to call it.</p>
<p>Generally when parsing tokens you’ll be bottoming out in various
<code>Cursor</code> methods. These are all documented as advancing the stream as
much as possible to the next token, skipping “irrelevant stuff” like
comments, whitespace, etc. The <code>Cursor</code> methods will also skip unknown
annotations. This means that if you parse <em>any</em> token, it will skip over
any number of annotations that are unknown at all times.</p>
<p>To parse an annotation you must, before parsing any token of the
annotation, register the annotation via this method. This includes the
beginning <code>(</code> token, which is otherwise skipped if the annotation isn’t
marked as registered. Typically parser parse the <em>contents</em> of an
s-expression, so this means that the outer parser of an s-expression
must register the custom annotation name, rather than the inner parser.</p>
<h5 id="return"><a href="#return">Return</a></h5>
<p>This function returns an RAII guard which, when dropped, will unregister
the <code>annotation</code> given. Parsing <code>annotation</code> is only supported while the
returned value is still alive, and once dropped the parser will go back
to skipping annotations with the name <code>annotation</code>.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>Let’s see an example of how the <code>@name</code> annotation is parsed for modules
to get an idea of how this works:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Module&lt;<span class="lifetime">&#39;a</span>&gt; {
    name: <span class="prelude-ty">Option</span>&lt;NameAnnotation&lt;<span class="lifetime">&#39;a</span>&gt;&gt;,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Parse&lt;<span class="lifetime">&#39;a</span>&gt; <span class="kw">for </span>Module&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>parse(parser: Parser&lt;<span class="lifetime">&#39;a</span>&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        <span class="comment">// Modules start out with a `module` keyword
        </span>parser.parse::&lt;kw::module&gt;()<span class="question-mark">?</span>;

        <span class="comment">// Next may be `(@name &quot;foo&quot;)`. Typically this annotation would
        // skipped, but we don&#39;t want it skipped, so we register it.
        // Note that the parse implementation of
        // `Option&lt;NameAnnotation&gt;` is the one that consumes the
        // parentheses here.
        </span><span class="kw">let </span>_r = parser.register_annotation(<span class="string">&quot;name&quot;</span>);
        <span class="kw">let </span>name = parser.parse()<span class="question-mark">?</span>;

        <span class="comment">// ... and normally you&#39;d otherwise parse module fields here ...

        </span><span class="prelude-val">Ok</span>(Module { name })
    }
}</code></pre></div>
<p>Another example is how we parse the <code>@custom</code> annotation. Note that this
is parsed as part of <code>ModuleField</code>, so note how the annotation is
registered <em>before</em> we parse the parentheses of the annotation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Module&lt;<span class="lifetime">&#39;a</span>&gt; {
    fields: Vec&lt;ModuleField&lt;<span class="lifetime">&#39;a</span>&gt;&gt;,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Parse&lt;<span class="lifetime">&#39;a</span>&gt; <span class="kw">for </span>Module&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>parse(parser: Parser&lt;<span class="lifetime">&#39;a</span>&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        <span class="comment">// Modules start out with a `module` keyword
        </span>parser.parse::&lt;kw::module&gt;()<span class="question-mark">?</span>;

        <span class="comment">// register the `@custom` annotation *first* before we start
        // parsing fields, because each field is contained in
        // parentheses and to parse the parentheses of an annotation we
        // have to known to not skip it.
        </span><span class="kw">let </span>_r = parser.register_annotation(<span class="string">&quot;custom&quot;</span>);

        <span class="kw">let </span><span class="kw-2">mut </span>fields = Vec::new();
        <span class="kw">while </span>!parser.is_empty() {
            fields.push(parser.parens(|p| p.parse())<span class="question-mark">?</span>);
        }
        <span class="prelude-val">Ok</span>(Module { fields })
    }
}

<span class="kw">enum </span>ModuleField&lt;<span class="lifetime">&#39;a</span>&gt; {
    Custom(Custom&lt;<span class="lifetime">&#39;a</span>&gt;),
    <span class="comment">// ...
</span>}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Parse&lt;<span class="lifetime">&#39;a</span>&gt; <span class="kw">for </span>ModuleField&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>parse(parser: Parser&lt;<span class="lifetime">&#39;a</span>&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        <span class="comment">// Note that because we have previously registered the `@custom`
        // annotation with the parser we known that `peek` methods like
        // this, working on the annotation token, are enabled to ever
        // return `true`.
        </span><span class="kw">if </span>parser.peek::&lt;annotation::custom&gt;()<span class="question-mark">? </span>{
            <span class="kw">return </span><span class="prelude-val">Ok</span>(ModuleField::Custom(parser.parse()<span class="question-mark">?</span>));
        }

        <span class="comment">// .. typically we&#39;d parse other module fields here...

        </span><span class="prelude-val">Err</span>(parser.error(<span class="string">&quot;unknown module field&quot;</span>))
    }
}</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Parser%3C'a%3E" class="impl"><a class="srclink rightside" href="../../src/wast/parser.rs.html#338">source</a><a href="#impl-Clone-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="srclink rightside" href="../../src/wast/parser.rs.html#338">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.1/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.72.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.72.1/src/core/clone.rs.html#129">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.1/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.72.1/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.72.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><section id="impl-Copy-for-Parser%3C'a%3E" class="impl"><a class="srclink rightside" href="../../src/wast/parser.rs.html#338">source</a><a href="#impl-Copy-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Parser%3C'a%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/1.72.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section><section id="impl-Send-for-Parser%3C'a%3E" class="impl"><a href="#impl-Send-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/1.72.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section><section id="impl-Sync-for-Parser%3C'a%3E" class="impl"><a href="#impl-Sync-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/1.72.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section><section id="impl-Unpin-for-Parser%3C'a%3E" class="impl"><a href="#impl-Unpin-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section><section id="impl-UnwindSafe-for-Parser%3C'a%3E" class="impl"><a href="#impl-UnwindSafe-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/1.72.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-Parser%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/any.rs.html#201">source</a><a href="#impl-Any-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.72.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/any.rs.html#202">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.72.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.72.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Parser%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.72.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.72.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Parser%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.72.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.72.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.72.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Parser%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/convert/mod.rs.html#722">source</a><a href="#impl-From%3CT%3E-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/convert/mod.rs.html#725">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Parser%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/convert/mod.rs.html#706">source</a><a href="#impl-Into%3CU%3E-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/convert/mod.rs.html#715">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.72.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-Parser%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/alloc/borrow.rs.html#82">source</a><a href="#impl-ToOwned-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.72.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/alloc/borrow.rs.html#87">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.72.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/alloc/borrow.rs.html#91">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.72.1/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.72.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Parser%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/convert/mod.rs.html#762">source</a><a href="#impl-TryFrom%3CU%3E-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.72.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/convert/mod.rs.html#769">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.72.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Parser%3C'a%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/convert/mod.rs.html#747">source</a><a href="#impl-TryInto%3CU%3E-for-Parser%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.72.1/src/core/convert/mod.rs.html#754">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.72.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.72.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>