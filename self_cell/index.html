<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Overview"><title>self_cell - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="self_cell" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../self_cell/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../self_cell/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate self_cell</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 1.0.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#macros">Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">self_cell</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/self_cell/lib.rs.html#1-676">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="overview"><a href="#overview">Overview</a></h2>
<p><code>self_cell</code> provides one macro-rules macro: <a href="macro.self_cell.html" title="macro self_cell::self_cell"><code>self_cell</code></a>. With this macro
you can create self-referential structs that are safe-to-use in stable Rust,
without leaking the struct internal lifetime.</p>
<p>In a nutshell, the API looks <em>roughly</em> like this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// User code:

</span><span class="macro">self_cell!</span>(
    <span class="kw">struct </span>NewStructName {
        owner: Owner,

        <span class="attr">#[covariant]
        </span>dependent: Dependent,
    }

    <span class="kw">impl </span>{Debug}
);

<span class="comment">// Generated by macro:

</span><span class="kw">struct </span>NewStructName(...);

<span class="kw">impl </span>NewStructName {
    <span class="kw">fn </span>new(
        owner: Owner,
        dependent_builder: <span class="kw">impl for</span>&lt;<span class="lifetime">&#39;a</span>&gt; FnOnce(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>Owner) -&gt; Dependent&lt;<span class="lifetime">&#39;a</span>&gt;
    ) -&gt; NewStructName { ... }
    <span class="kw">fn </span>borrow_owner&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>Owner { ... }
    <span class="kw">fn </span>borrow_dependent&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>Dependent&lt;<span class="lifetime">&#39;a</span>&gt; { ... }
}

<span class="kw">impl </span>Debug <span class="kw">for </span>NewStructName { ... }</code></pre></div>
<p>Self-referential structs are currently not supported with safe vanilla Rust.
The only reasonable safe alternative is to have the user juggle 2 separate
data structures which is a mess. The library solution ouroboros is really
expensive to compile due to its use of procedural macros.</p>
<p>This alternative is <code>no_std</code>, uses no proc-macros, some self contained
unsafe and works on stable Rust, and is miri tested. With a total of less
than 300 lines of implementation code, which consists mostly of type and
trait implementations, this crate aims to be a good minimal solution to the
problem of self-referential structs.</p>
<p>It has undergone <a href="https://users.rust-lang.org/t/experimental-safe-to-use-proc-macro-free-self-referential-structs-in-stable-rust/52775">community code
review</a>
from experienced Rust users.</p>
<h4 id="fast-compile-times"><a href="#fast-compile-times">Fast compile times</a></h4><div class="example-wrap"><pre class="language-txt"><code>$ rm -rf target &amp;&amp; cargo +nightly build -Z timings

Compiling self_cell v0.7.0
Completed self_cell v0.7.0 in 0.2s
</code></pre></div>
<p>Because it does <strong>not</strong> use proc-macros, and has 0 dependencies
compile-times are fast.</p>
<p>Measurements done on a slow laptop.</p>
<h4 id="a-motivating-use-case"><a href="#a-motivating-use-case">A motivating use case</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>self_cell::self_cell;

<span class="attr">#[derive(Debug, Eq, PartialEq)]
</span><span class="kw">struct </span>Ast&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw">pub </span>Vec&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str&gt;);

<span class="macro">self_cell!</span>(
    <span class="kw">struct </span>AstCell {
        owner: String,

        <span class="attr">#[covariant]
        </span>dependent: Ast,
    }

    <span class="kw">impl </span>{Debug, Eq, PartialEq}
);

<span class="kw">fn </span>build_ast_cell(code: <span class="kw-2">&amp;</span>str) -&gt; AstCell {
    <span class="comment">// Create owning String on stack.
    </span><span class="kw">let </span>pre_processed_code = code.trim().to_string();

    <span class="comment">// Move String into AstCell, then build Ast inplace.
    </span>AstCell::new(
       pre_processed_code,
       |code| Ast(code.split(<span class="string">&#39; &#39;</span>).filter(|word| word.len() &gt; <span class="number">1</span>).collect())
    )
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>ast_cell = build_ast_cell(<span class="string">&quot;fox = cat + dog&quot;</span>);

    <span class="macro">println!</span>(<span class="string">&quot;ast_cell -&gt; {:?}&quot;</span>, <span class="kw-2">&amp;</span>ast_cell);
    <span class="macro">println!</span>(<span class="string">&quot;ast_cell.borrow_owner() -&gt; {:?}&quot;</span>, ast_cell.borrow_owner());
    <span class="macro">println!</span>(<span class="string">&quot;ast_cell.borrow_dependent().0[1] -&gt; {:?}&quot;</span>, ast_cell.borrow_dependent().<span class="number">0</span>[<span class="number">1</span>]);
}</code></pre></div>
<div class="example-wrap"><pre class="language-txt"><code>$ cargo run

ast_cell -&gt; AstCell { owner: &quot;fox = cat + dog&quot;, dependent: Ast([&quot;fox&quot;, &quot;cat&quot;, &quot;dog&quot;]) }
ast_cell.borrow_owner() -&gt; &quot;fox = cat + dog&quot;
ast_cell.borrow_dependent().0[1] -&gt; &quot;cat&quot;
</code></pre></div>
<p>There is no way in safe Rust to have an API like <code>build_ast_cell</code>, as soon
as <code>Ast</code> depends on stack variables like <code>pre_processed_code</code> you can’t
return the value out of the function anymore. You could move the
pre-processing into the caller but that gets ugly quickly because you can’t
encapsulate things anymore. Note this is a somewhat niche use case,
self-referential structs should only be used when there is no good
alternative.</p>
<p>Under the hood, it heap allocates a struct which it initializes first by
moving the owner value to it and then using the reference to this now
Pin/Immovable owner to construct the dependent inplace next to it. This
makes it safe to move the generated SelfCell but you have to pay for the
heap allocation.</p>
<p>See the documentation for <a href="macro.self_cell.html" title="macro self_cell::self_cell"><code>self_cell</code></a> to dive further into the details.</p>
<p>Or take a look at the advanced examples:</p>
<ul>
<li>
<p><a href="https://github.com/Voultapher/self_cell/tree/main/examples/fallible_dependent_construction">Example how to handle dependent construction that can
fail</a></p>
</li>
<li>
<p><a href="https://github.com/Voultapher/self_cell/tree/main/examples/lazy_ast">How to build a lazy AST with
self_cell</a></p>
</li>
<li>
<p><a href="https://github.com/Voultapher/self_cell/tree/main/examples/owner_with_lifetime">How to use an owner type with
lifetime</a></p>
</li>
</ul>
<h4 id="min-required-rustc-version"><a href="#min-required-rustc-version">Min required rustc version</a></h4>
<p>By default the minimum required rustc version is 1.51.</p>
<p>There is an optional feature you can enable called “old_rust” that enables
support down to rustc version 1.36. However this requires polyfilling std
library functionality for older rustc with technically UB versions. Testing
does not show older rustc versions (ab)using this. Use at your own risk.</p>
<p>The minimum versions are a best effor and may change with any new major
release.</p>
</div></details><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.self_cell.html" title="macro self_cell::self_cell">self_cell</a></div><div class="desc docblock-short">This macro declares a new struct of <code>$StructName</code> and implements traits
based on <code>$AutomaticDerive</code>.</div></li></ul></section></div></main></body></html>